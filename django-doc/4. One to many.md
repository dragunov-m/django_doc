```python
class Company(models.Model):
    name = models.CharField(max_length=30)
 
class Product(models.Model):
    company = models.ForeignKey(Company, on_delete = models.CASCADE)
    name = models.CharField(max_length=30)
    price = models.IntegerField()
```

В данном случае модель __Company__ представляет производителя и является главной моделью, а модель __Product__ представляет товар компании и является зависимой моделью.

Конструктор типа __models.ForeignKey__ настраивает связь с главной сущностью. Первый параметр указывает, с какой моделью будет создаваться связь - в данном случае это модель __Company__. Второй параметр - __on_delete__ задает опцию удаления объекта текущей модели при удалении связанного объекта главной модели. Всего для параметра on_delete мы можем использовать следующие значения:

* __models.CASCADE__: автоматически удаляет строку из зависимой таблицы, если удаляется связанная строка из главной таблицы

* __models.PROTECT__: блокирует удаление строки из главной таблицы, если с ней связаны какие-либо строки из зависимой таблицы

* __models.SET_NULL__: устанавливает NULL при удалении связанной строка из главной таблицы

* __models.SET_DEFAULT__: устанавливает значение по умолчанию для внешнего ключа в зависимой таблице. В этом случае для этого столбца должно быть задано значение по умолчанию

* __models.DO_NOTHING__: при удалении связанной строки из главной таблицы не производится никаких действий в зависимой таблице

## Операции с моделями

Из определения таблиц мы видим, что модель __Product__ связана с таблицей __Company__ через столбец "__company_id__". Однако в самом определении модели Product есть поле company, через которое можно получить связанную сущность:

```python
# получение id связанной с товаром компании
Product.objects.get(id=1).company.id
 
# получение названия связанной с товаром компании
Product.objects.get(id=1).company.name
 
# получение товаров, которые принадлежат к компании "Apple"
Product.objects.filter(company__name="Apple")
```

С помощью выражения модель__свойство (два подчеркивания) можно использовать свойство главной модели для фильтрации по объектам зависимой модели.

Хотя с точки зрения модели __Company__ она не имеет никаких свойств, которые связывали бы ее с моделью __Product__. Но с помощью синтаксиса

```python
"главная_модель"."зависимая_модель"_set
```

можно изменить направление связи. Например:

```python
apple = Company.objects.get(name="Apple")
 
# получение всех товаров
apple.product_set.all()
 
# получение количества товаров
apple.product_set.count()
 
# получение товаров, название которых начинается на "iPhone"
apple.product_set.filter(name__startwith="iPhone")
```

Причем с помощью выражения __set__ можно выполнять операции добавления, изменения, удаления объектов зависимой модели из главной модели.

```python
# создаем объект Company
apple = Company.objects.create(name="Apple")
 
 
# создание товара определенной компании
apple.product_set.create(name="iPhone 8", price=67890)
 
# отдельное создание объекта с последующим добавлением
ipad = Product(name="iPad", price=34560)
# при добавлении необходимо указать параметр bulk =False
apple.product_set.add(ipad, bulk=False)
 
# исключает из компании все товары, 
# при этом товары остаются в бд, просто им не назначена компания
# работает, если в зависимой модели ForeignKey(Company, null = True)
# apple.product_set.clear()
 
# то же самое, только в отношении одного объекта
# ipad = Product.objects.get(name="iPad")
# apple.product_set.remove(ipad)
```

Стоит отметить три метода:

* __add()__: добавляет связь между объектом зависимой модели и объектом главной модели. В своей сути этот метод фактически вызывает для модели метод update() для добавления связи. Однако это требует, чтобы обе модели уже были в базе данных. И чтобы обойти это ограничение, применяется параметр bulk=False, для того, чтобы объект зависимой модели сразу был добавлен и для него была установлена связь.
* __clear()__: удаляет связь между всеми объектами зависимой модели и объектом главной модели. При этом сами объекты зависимой модели остаются в базе данных, и для их внешнего ключа устанавливается значение NULL. Поэтому данный метод будет работать, если в самой зависимой модели при установки связи использовался параметр null=True: ForeignKey(Company, null = True).
* __remove()__: также, как и clear() удаляет связь, только между одним объектом зависимой модели и объектом главной модели. При этом также все объекты остаются в бд. И также в самой зависимой модели при установки связи должен использоваться параметр null=True

Как модели отображаются в бд:

![[Pasted image 20230219213521.png]]
![[Pasted image 20230219213553.png]]